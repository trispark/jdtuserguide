<!DOCTYPE html>
<html lang="en">
@@include('../partials/_head.html')
<body>

@@include('../partials/_nav.html')

<div class="container">

  <div class="starter-template">
    <h1>Working with DICOM files and datasets</h1>
    <!--
    <p class="lead">Use this document as a way to quickly start any new project.<br> All you get is this text and a mostly barebones HTML document.</p>
    -->
  </div>

  <div class="row">
    <div class="col-md-3">
      <div class="bs-docs-sidebar" data-spy="affix" data-offset-top ="215" data-offset-bottom="0">
        <nav>
          <ul class="nav nav-stacked fixed">
            <li><a href="#dicomfileformat">DICOM File Format</a></li>
            <li><a href="#readingdicomfiles">Reading DICOM Files and Data Sets</a></li>
            <li><a href="#tagreadevents">Listening To Tag Read Events</a></li>
            <li><a href="#writingdicomfiles">Writing DICOM Files and Data Sets</a></li>
            <li><a href="#typemap">Java DICOM Type Map</a></li>
            <li><a href="#uidregistry">Using the UID Registry</a></li>
            <li><a href="#elementregistry">Using the Data Element Registry</a></li>
            <li><a href="#retrievingvalues">Retrieving values of a Data Element</a></li>
            <li><a href="#updatingvalues">Adding and Updating values of a Data Element</a></li>
            <li><a href="#listing">Listing the contents of a DICOM file</a></li>
            <li><a href="#charsets">Working with extended or replacements charsets</a></li>
          </ul>
        </nav>
      </div>
    </div>
    <div class="col-md-9">
      <div id="dicomfileformat">
        <h1>DICOM File Format</h1>
        The DICOM File Format is described in Part 10 of the DICOM Standard: "Media Storage and File Format for Data Interchange".
        A DICOM file consists of a file header followed by a File Meta Information Data Set and a Data Set representing a single SOP Instance.

        <h3>File Header</h3>
        The File Header is made up of a 128-byte File Preamble followed by a 4-byte prefix.
        The prefix consists of the uppercase characters 'D','I','C','M'. The DICOM standard does not define how the 128-byte File Preamble should be structured.
        The purpose of the File Preamble is to provide a way for a DICOM file to be compatible with a number of common image file formats.
        For example the File Preamble my contain offset information that allows an application to have direct access to the image data without having to parse the complete DICOM file.
        If the File Preamble is not used all bytes must be zero.

        Note: the file header is normally a required part of a DICOM file, but sometimes only the dataset following the file header is stored physically on disk.
        This may for example be the case in the internal storage of PACS systems. JDT is also capable of reading and writing data sets stored as files without a file header.

        <h3>File Meta Information</h3>
        The File Meta Information follows the File Header and has the structure of a Data Set with Data Elements.
        All Data Elements have group number 0x0002 and contain specific information about the DICOM file.
        The Transfer Syntax of the File Meta Information Data set is always Explicit Little Endian.
        The Transfer Syntax of the Data Set following the File Meta Information is encoded as a Data Element within the File Meta Information.
        JDT reads and writes File Meta Information and stores it in a DicomObject accessible from the DicomObject instance that contains the Data Set of the rest of the DICOM file.

        <h3>Data Set</h3>
        The Data Set is stored in the portion of the file following the file header. A data set represents a single SOP instance of a particular SOP class.
        The Data Set contains public Data Elements identified by a tag with an even group number and it may also contain private Data Elements identified by a tag with an odd group number.

        <h3>Data Elements</h3>
        Data Elements are the individual units of information within a DICOM file.
        Data Elements may be nested. This means the value of a Data Element may contain a number of Data Sets.
        Data Elements that contain nested Data Sets are called Sequences and a single Data Set that is nested within a Sequence is called a Sequence Item.
      </div>

      <h1 id="readingdicomfiles">Reading DICOM Files and Data Sets</h1>
      DICOM files and raw Data Sets (without the 128 byte preamble and group 0x0002) can be read from arbitrary inputstreams using the com.archimed.dicom.DicomReader class.
      The DicomReader class has a number of methods for reading DICOM data.

      <h3>DicomObject read (java.io.InputStream in)</h3>
      This method can read both raw data sets and DICOM files and will return a DicomObject containing all the data elements within the DICOM file or raw data set.
      When the supplied inputstream points a to DICOM File, the File Meta Information is also read and stored in a separate DicomObject retrievable with getFileMetaInformation().
      When the supplied inputstream points to a raw data set, the transfer syntax of the data set is assumed to be Implicit VR Little Endian.
      See the other read methods for reading raw data sets in other transfer syntaxes.
      <br>
      The simplest way of using this method is with the following code:

        <pre><code class="lang-java">FileInputStream fin = new FileInputStream ();
          DicomReader dcmReader = new DicomReader();
          DicomObject dcm = dcmReader.read(fin);</code></pre>

      <h3>DicomObject read (java.io.InputStream in,boolean readpixels)</h3>

      This method does the same as the previous one but in addition allows you to specify whether to parse or skip pixel data during the reading.
      This method is mainly here for backwards compatibility. Skipping arbitrary tags can also be achieved by registering a TagReadListener on the DicomReader.

      <h3>DicomObject read (java.io.InputStream in, int transfersyntax , boolean readpixels)</h3>
      Use this method to read a raw data set. The transfer syntax is not detected but must be specified.

      Note: The DicomObject class also contains a number of read methods. These methods are maintained for backwards compatibility.
      New implementations should use the DicomReader class to read DICOM files and data sets.

      <h1 id="tagreadevents">Listening To Tag Read Events</h1>
      A TagReadListener makes it possible to listen to the reading of individual data elements and possibly modify the DicomObject while it is being read.
      TagReadListeners are registered with a DicomReader. During the reading of a DICOM file or raw data set,
      the DicomReader will fire a TagReadEvent just before reading the value field of a data element for which TagReadListeners are registered.
      The TagReadEvent contains a property dataReadStatus that determines how the value field of a data element is read after all listeners are notified:

      <h4>READ_TAG_DATA</h4>
      after all the listeners have been notified the DicomReader will continue to read the value field of the data element normally as any other data element. This is the default.

      <h4>SKIP_TAG_DATA</h4>
      the DicomReader will skip the entire value field of the data element and will place an empty data element in the DicomObject.
      The underlying inputstream will be moved forward to the beginning of the next data element by the DicomReader.

      <h4>SKIP_TAG</h4>
      The DicomReader will skip the entire value field of the data element. No empty data element is places within the DicomObject.
      The underlying inputstream will be moved forward to the beginning of the next data element by the DicomReader.

      <h4>NEXT_TAG</h4>
      The DicomReader assumes that one of the listener will read the value field of the data element and that when all listeners are notified,
      the inputstream is positioned just before the next data element or the end of the stream if this was the last data element in the data set.

      <h1 id="writingdicomfiles">Writing DICOM Files and Data Sets</h1>
      DICOM files and raw datasets (without the 128 byte file header and 0x0002 group) can be written to arbitrary input streams using the com.archimed.dicom.DicomWriter class.
      The DicomWriter class has three write methods for writing to output streams. These methods allow you to control:
      <p>
      <ul>
        <li>File Meta Information
        <li>Transfer Syntax
        <li>Generation of group length data elements
        <li>Writing sequences with defined or undefined length
      </ul>
      </p>
      <pre><code class="lang-java">DicomWriter.write ( DicomObject dcm,OutputStream out, boolean dicomfile)</code></pre>
      <p>
        This method writes a DicomObject to an outputstream as a DICOM file or a data set depending on the boolean argument dicomfile.
      </p>
      <p>
        File Meta Information: The File Meta Information to be used when writing a DICOM file, can be specified through the FileMetaInformation property of the DicomObject. If this property contains a non-null DicomObject, the File Meta Information data elements - data elements of group 2 - of the DicomObject contained in this property are used. If this property is null, the DicomReader generates File Meta Information with the following data elements:
      </p>
      <table class="table table-condensed">
        <tr><th>Tag</th><th>Name</th><th>Value</th></tr>
        <tr><td>(0002,0001)</td><td>File Meta Information Version</td><td>	0001h</td></tr>
        <tr><td>(0002,0002)</td><td>Media Storage SOP Class UID</td><td>	initialized by SOP Class UID or exception thrown if absent</td></tr>
        <tr><td>(0002,0003)</td><td>Media Storage SOP Instance UID</td><td>	initialized by SOP Instance UID or exception thrown if absent
        <tr><td>(0002,0010)</td><td>Transfer Syntax UID</td><td>	Implicit VR Little Endian</td></tr>
        <tr><td>(0002,0012)</td><td>Implementation Class UID</td><td>	initialized by constant JDT.DEFAULT_IMPLEMENTATION_CLASS_UID</td></tr>
        <tr><td>(0002,0013)</td><td>Implementation Version Name</td><td>	initialized by constant JDT.DEFAULT_IMPLEMENTATION_VERSION_NAME</td></tr>
      </table>
      <p>
        <strong>Transfer Syntax:</strong> When writing a raw Data Set, the transfer syntax is Implicit VR Little Endian. When writing a DICOM file, the Transfer Syntax is determined by the FileMetaInformation. If no File Meta Information is specified, the DICOM file is written in Implicit VR Little Endian Transfer Syntax.
      </p><p>
      <strong>Sequence lengths:</strong> sequences are written with undefined length when this write method is used.
    </p><p>
      <strong>Group lengths:</strong> group lengths are generated and added to the data set during to writing to the outputstream.
    </p>

        <pre><code class="lang-java">DicomWriter.write ( DicomObject dcm,OutputStream out, boolean dicomfile,
          int transfersyntax, boolean sequencesUndefined)</code></pre>

      <p>
        This method writes a DicomObject to an outputstream as a DICOM file or a data set depending on the boolean argument dicomfile.
      </p>
      <p>
        <strong>File Meta Information:</strong> The File Meta Information to be used when writing a DICOM file, can be specified through the FileMetaInformation property of the DicomObject. If this property contains a non-null DicomObject, the File Meta Information data elements - data elements of group 2 - of the DicomObject contained in this property are used. If this property is null, the DicomReader generates File Meta Information with the following data elements:
      </p>
      <table class="table table-condensed">
        <tr><th>Tag</th><th>Name</th><th>Value</th></tr>
        <tr><td>(0002,0001)</td><td>File Meta Information Version	0001h</td></tr>
        <tr><td>(0002,0002)</td><td>Media Storage SOP Class UID</td><td>initialized by SOP Class UID or exception thrown if absent</td></tr>
        <tr><td>(0002,0003)</td><td>Media Storage SOP Instance UID</td><td>initialized by SOP Instance UID or exception thrown if absent</td></tr>
        <tr><td>(0002,0010)</td><td>Transfer Syntax UID</td><td>initialized by the Transfer Syntax specified in the transfersyntax argument</td></tr>
        <tr><td>(0002,0012)</td><td>Implementation Class UID</td><td>initialized by constant JDT.DEFAULT_IMPLEMENTATION_CLASS_UID</td></tr>
        <tr><td>(0002,0013)</td><td>Implementation Version Name</td><td>initialized by constant JDT.DEFAULT_IMPLEMENTATION_VERSION_NAME</td></tr>
      </table>
      <p>
        <strong>Transfer Syntax:</strong> specified by the transfersyntax argument.
      </p><p>
      <strong>Sequence lengths:</strong> sequences are written with undefined length when the value of the sequencesUndefined argument is true and written with defined length when the value is false.
    </p><p>
      <strong>Group lengths:</strong> group lengths are generated and added to the data set during to writing to the outputstream.
    </p>

        <pre><code class="lang-java">DicomWriter.write ( DicomObject dcm,OutputStream out, boolean dicomfile,
          int transfersyntax, boolean sequencesUndefined, boolean groupLengths)</code></pre>
      <p>
        This method is identical to the previous write method with the exception that the generation of group length data elements can be turned on or off
        depending on the value of the groupLengths argument.
      </p>
      <strong>Note:</strong> The DicomObject class also contains a number of write methods. These methods are maintained for backwards compatibility. New implementations should use the DicomWriter class to write DICOM files and data sets.
      </p>

      <h1 id="typemap">Java DICOM Type Map</h1>
      <p>
        The DICOM standard defines a number of data types known as value representations (VR) and specifies for every data element which value Representation
        to use for data typing and formatting the value(s) of that data element. Similarly the Java Language has a number of data types such as String,Integer,Float,...
        and JDT has defined a few extra custom types to represent values of data elements.
      </p><p>
      JDT contains two types of setters/getters to retrieve and modify values of data elements in a dataset:
    </p>
      <ul>
        <li>Typesafe set,add or get methods in the DataElement class and DicomObject class that take or return a specific data type like String,Float,Person,...
        <li>Type unsafe set,add or get methods that take or return an instance of java.lang.Object
      </ul>
      <p>
        <strong>Deprecation Note:</strong> Type unsafe getters and setters like DicomObject.set(java.lang.Object),java.lang.Object DicomObject.get() are deprecated and new implementations should avoid using them.
      </p>
      <h4>Type Map</h4>
      <p>
        The map below specifies the supported getters and setters of the DicomObject class and DataElement class.
        For example, the AE value representation has String and byte[] as supported types for typesafe setters and getters of DicomObject and DataElement.
        This means that for AE data elements the all set,add and get methods are supported that take or return a byte array or a String as an argument or return type.
        Other set,add or get methods will throw an exception.
      </p><p>
      <strong>Note:</strong> All value representations except SQ support getString(), but for some this is only to get a human readable representation of the value of tag,possibly truncated. This is especially the case for data elements with VR of OW,OB,UN.
    </p>
      <p>
      <table class='table table-condensed'>
        <tr>
          <th class='confluenceTh'> DICOM VR </th>
          <th class='confluenceTh'> Supported typesafe getters </th>
          <th class='confluenceTh'> Supported typesafe setters </th>
        </tr>
        <tr>
          <td class='confluenceTd'> AE </td>
          <td class='confluenceTd'> String,byte[] </td>
          <td class='confluenceTd'> String,byte[] </td>
        </tr>
        <tr>
          <td class='confluenceTd'> AS </td>
          <td class='confluenceTd'> String,byte[] </td>
          <td class='confluenceTd'> String,byte[] </td>
        </tr>
        <tr>
          <td class='confluenceTd'> AT </td>
          <td class='confluenceTd'> ATValue,String </td>
          <td class='confluenceTd'> ATValue </td>
        </tr>
        <tr>
          <td class='confluenceTd'> CS </td>
          <td class='confluenceTd'> String,byte[] </td>
          <td class='confluenceTd'> String,byte[] </td>
        </tr>
        <tr>
          <td class='confluenceTd'> DA </td>
          <td class='confluenceTd'> String,byte[] </td>
          <td class='confluenceTd'> String,byte[] </td>
        </tr>
        <tr>
          <td class='confluenceTd'> DS </td>
          <td class='confluenceTd'> BigDecimal,String,byte[] </td>
          <td class='confluenceTd'> BigDecimal,String,byte[] </td>
        </tr>
        <tr>
          <td class='confluenceTd'> DT </td>
          <td class='confluenceTd'> String,byte[] </td>
          <td class='confluenceTd'> String,byte[] </td>
        </tr>
        <tr>
          <td class='confluenceTd'> FL </td>
          <td class='confluenceTd'> String,Float </td>
          <td class='confluenceTd'> String,Float </td>
        </tr>
        <tr>
          <td class='confluenceTd'> FD </td>
          <td class='confluenceTd'> String,Double </td>
          <td class='confluenceTd'> String,Double </td>
        </tr>
        <tr>
          <td class='confluenceTd'> IS </td>
          <td class='confluenceTd'> Integer,Long,Short,String,byte[] </td>
          <td class='confluenceTd'> Integer,Long,Short,String,byte[] </td>
        </tr>
        <tr>
          <td class='confluenceTd'> LO </td>
          <td class='confluenceTd'> String,byte[] </td>
          <td class='confluenceTd'> String,byte[] </td>
        </tr>
        <tr>
          <td class='confluenceTd'> LT </td>
          <td class='confluenceTd'> String </td>
          <td class='confluenceTd'> String </td>
        </tr>
        <tr>
          <td class='confluenceTd'> OB </td>
          <td class='confluenceTd'> byte[],String </td>
          <td class='confluenceTd'> byte[],String </td>
        </tr>
        <tr>
          <td class='confluenceTd'> OW </td>
          <td class='confluenceTd'> byte[],String </td>
          <td class='confluenceTd'> byte[],String </td>
        </tr>
        <tr>
          <td class='confluenceTd'> OF </td>
          <td class='confluenceTd'> float[],String </td>
          <td class='confluenceTd'> float[] </td>
        </tr>
        <tr>
          <td class='confluenceTd'> PN </td>
          <td class='confluenceTd'> Person,String,byte[] </td>
          <td class='confluenceTd'> Person,String,byte[] </td>
        </tr>
        <tr>
          <td class='confluenceTd'> SH </td>
          <td class='confluenceTd'> String,byte[] </td>
          <td class='confluenceTd'> String,byte[] </td>
        </tr>
        <tr>
          <td class='confluenceTd'> SL </td>
          <td class='confluenceTd'> Long,Integer,String </td>
          <td class='confluenceTd'> Long,Integer,Short,String </td>
        </tr>
        <tr>
          <td class='confluenceTd'> SQ </td>
          <td class='confluenceTd'> getSequenceItem(DicomObject) </td>
          <td class='confluenceTd'> addSequenceItem(DicomObject),setSequenceItem(DicomObject) </td>
        </tr>
        <tr>
          <td class='confluenceTd'> SS </td>
          <td class='confluenceTd'> Long,Integer,Short,String </td>
          <td class='confluenceTd'> Long,Integer,Short,String </td>
        </tr>
        <tr>
          <td class='confluenceTd'> ST </td>
          <td class='confluenceTd'> String,byte[] </td>
          <td class='confluenceTd'> String,byte[] </td>
        </tr>
        <tr>
          <td class='confluenceTd'> TM </td>
          <td class='confluenceTd'> String,byte[] </td>
          <td class='confluenceTd'> String,byte[] </td>
        </tr>
        <tr>
          <td class='confluenceTd'> UI </td>
          <td class='confluenceTd'> String,byte[] </td>
          <td class='confluenceTd'> String,byte[] </td>
        </tr>
        <tr>
          <td class='confluenceTd'> UL </td>
          <td class='confluenceTd'> Long,String </td>
          <td class='confluenceTd'> Long,Integer,Short,String </td>
        </tr>
        <tr>
          <td class='confluenceTd'> UN </td>
          <td class='confluenceTd'> byte[],String </td>
          <td class='confluenceTd'> byte[],String </td>
        </tr>
        <tr>
          <td class='confluenceTd'> US </td>
          <td class='confluenceTd'> Long,Integer,String </td>
          <td class='confluenceTd'> Long,Integer,Short,String </td>
        </tr>
        <tr>
          <td class='confluenceTd'> UT </td>
          <td class='confluenceTd'> String,byte[] </td>
          <td class='confluenceTd'> String,byte[] </td>
        </tr>
      </table>
      </p>

      <h1 id="uidregistry">Using the UID Registry</h1>
      <p>
        The DICOM standard defines a registry of unique identifiers (UID) that are used throughout the standard.
        JDT has defined registry classes that hold these unique identifiers together with a description. More specifically JDT defines registry classes for
      </p>
      <ul>
        <li>SOP Class UIDs: com.archimed.dicom.SOPClass
        <li>Meta SOP Class UIDs: com.archimed.dicom.MetaSOPClass
        <li>Transfer Syntax UIDs: com.archimed.dicom.TransferSyntax
        <li>SOP Instance UIDs: com.archimed.dicom.SOPInstance
      </ul>
      <p>
        All UID registry classes have defined constants which are used to identify the UIDs contained in the registry.
        All registry classes inherit from the com.archimed.dicom.UID superclass. Registry entries are represented as com.archimed.dicom.UIDEntry objects.
      </p><p>
      The class com.archimed.dicom.SOPClass represents every publicly defined SOP class as an int constant and as a constant of type SOPClassUID.
      For example, the Basic Film Box SOP class is both represented as
    </p>

        <pre><code class="lang-java">public static final int BasicFilmBox;
          public static final SOPClassUID BasicFilmBoxUID;</code></pre>

      <p>
        The class com.archimed.dicom.TransferSyntax represents every publicly defined transfer syntax as an int constant and as a constant of type TransferSyntaxUID.
        For example, the Basic Film Box SOP class is both represented as
      </p>

        <pre><code class="lang-java">public static final int ImplicitVRLittleEndian;
          public static final TransferSyntaxUID ImplicitVRLittleEndianUID;</code></pre>

      <h4>Working with the registry classes</h4>
      <p>
        The UID class provides methods for looking up UIDs based on their value or based on a defined constant corresponding to the UID. For example, to retrieve the UIDEntry instance for the JPEG Baseline Transfer Syntax based on the constant defined in the TransferSyntax registry class:
      </p>
      <pre><code class="lang-java">UIDEntry entry = UID.getUIDEntry(TransferSyntax.JPEGBaseline);</code></pre>
      <p>
        or alternatively using the value of UID:
      </p>
      <pre><code class="lang-java">UIDEntry entry = UID.getUIDEntry("1.2.840.10008.1.2.4.50");</code></pre>
      <p>
        A UIDEntry has the following properties:
      </p>
      <ul>
        <li>The name of the UID
        <li>The value of the UID
        <li>The constant representing the UID in the registry class
        <li>The type of UID (SOP Class,Transfer Syntax,Meta SOP Class,SOP Instance)
      </ul>
      <p>
        <strong>Note:</strong> When using int constants of the class SOPClass and TransferSyntax in UID.getUIDEntry, the returned UIEntry objects are in fact the defined SOPClassUID constants and TransferSyntaxUID constants. So the following holds: TransferSyntax.JPEGBaselineUID == UID.getUIDEntry(TransferSyntax.JPEGBaseline)
      </p>

      <h4>Adding new entries to the SOP Class registry</h4>
      <p>
        New UIDs can be added dynamically to The SOP Class registry with the addEntry methods of SOPClass.
        The addEntry method returns a constant that can be used to identify the newly added UID based on a constant.
        A possible way of doing this is by subclassing SOPClass:
      </p>
        <pre><code class="lang-java">public class MySOPClass extends SOPClass
          {
          public static int MySOP;

          static
          {
          try
          {
          UIDEntry entry = new UIDEntry(-1, "1.2.3.4.5", "My SOP Storage", "MY", UIDEntry.SOPClass);
          MySOP = SOPClass.addEntry(entry);
          }catch(DicomException ex)
          {
          ex.printStackTrace();
          }
          }
          }</code></pre>
      <h4>Storage SOP Classes</h4>
      <p>
        The SOPClass registry class provides methods to list Storage SOP Classes UIDs and to check if a SOP Class UID actually represents a Storage SOP Class:
      </p>
      <ul>
        <li>listStorageSOPClasses: provides a List of UIDEntry objects of all Storage SOP Classes in the SOPClass registry
        <li>isStorageSOPClass: expects a SOP Class constant and returns true or false depending on whether the constant represents a Storage SOP Class or not.
      </ul>

      <h1 id="elementregistry">Using the Data Element Registry</h1>
      <p>
        The DICOM standard defines a registry of all public DICOM Data Elements.
        This registry assigns a unique tag, a name, a value representation and semantics to every Data Element that it contains.
        As the DICOM standard evolves, this registry grows together with the DICOM data model.
      </p>
      <p>
        The <code>com.archimed.dicom.DDict</code> class represents the Data Element Registry.
        It defines a constant for every Data Element defined within the registry and it contains the Value Representation, group-element pair and description of every Data Element.
        The name of the constant is in most cases the concatenated description for the Data Element given in the DICOM Standard
        with the exception that illegal characters according to the Java syntax are removed. The DDict class has constants defined for:
      </p>
      <ul>
        <li>DICOM Command Elements (group 0x0000)
        <li>DICOM Data Elements
        <li>DICOM File Meta Elements (group 0x0002)
        <li>DICOM Directory Structuring Elements (group 0x0004)
      </ul>
      <p>
        The DDict class also defines constants for all Value Representations.
      </p>
      <p>
        A number of set and get methods of DicomObject expect a DDict constant as one of it's arguments to identify the Data Element for which to set or retrieve values.
      </p>
      <h4>Retrieving information about a Data Element registered in DDict</h4>
      <p>
        The DDict class contains methods to retrieve
      </p>
      <ul>
        <li>the description
        <li>the group-element pair
        <li>the value representation as a constant
        <li>the value representation as a 2-character string
      </ul>
      for a Data Element registered with DDict and given a DDict constant representing a Data Element.

      <h4>Adding new tag definitions to DDict</h4>
      <p>
        You can add extra entries to DDict using the addEntry method.
        This method returns a constant that you can use to identify the Data Element in DicomObject methods that expect a DDict constant.
        A possible way of adding new entries to DDict is by subclassing it in the following way:
      </p>

        <pre><code class="lang-java">import com.archimed.dicom.*;

          public class MyDDict
          {
          public static int dMyTag1;
          public static int dMyTag2;

          //When this class is used for the first time, the tags are initialized and added to the DDict.
          //The constants used for referencing the tags are also initialized.

          static
          {
          try
          {
          dMyTag1 = DDict.addEntry(new DDictEntry(0x0011,0x0002,DDict.tFD,"My Tag 1","1"));
          dMyTag2 = DDict.addEntry(new DDictEntry(0x0011,0x0007,DDict.tLO,"My Tag 2","1"));
          }
          catch(DicomException e)
          {
          System.out.println("unable to add private tags to dictionary: " + e);
          }
          }
          }</code></pre>
      <p>
        The MyDDict class can be used as follows:
      </p>
        <pre><code class="lang-java">DicomObject dcm = new DicomObject();
          dcm.set(DDict.dPatientName,"Doe^John");

          //Add some tags of MyDDict
          dcm.set(MyDDict.dMyTag1,new Double(123.456));
          dcm.set(MyDDict.dMyTag2,"My Value";</code></pre>

      <h1 id="retrievingvalues">Retrieving values of a Data Element</h1>
      <p>
        A DICOM file and a  Data Set are represented in memory by an object of class <code>com.archimed.dicom.DicomObject</code>.
        This class acts as a container of Data Elements. Depending on the Value Multiplicity a Data Element can hold one or more values.
        Data Elements can also be empty , which means that they are present in the Data Set or DICOM file but they don't contain any values: the length of their value field is 0.
        The Java type of the retrieved values follows the Java-DICOM type map.
      </p>
      <h4>Retrieving the number of values stored in a Data Element</h4>
      <p>
        The getSize method and getSize_ge method return the number of values stored a Data Element.
        If the Data Element is present within the DICOM File or Data Set but is empty, the methods will return 0. If the Data Element is not present, the methods will return -1.
      </p><p>
      For example, suppose a DicomObject dcm contains an ImageType Data Element with values 'DERIVED\SECONDARY'.
      (The backslash separates the different values in the Data Element for this particular Value Representation). The number of values in this example is 2:
    </p>
      <pre><code class="lang-java">int multiplicity = dcm.getSize(DDict.dImageType); //will return value 2</code></pre>
      <p>
        or alternatively with (group,element) pair:
      </p>
      <pre><code class="lang-java">int multiplicity = dcm.getSize_ge(0x0008,0x0008); //will return value 2</code></pre>

      <h4>Retrieving values of a Data Element not contained in a Sequence Item</h4>
      <h5>A] The Data Element contains a single value</h5>
      <p>
        Use the get method of DicomObject that takes as an argument either the corresponding DDict constant of the Data Element or use
        the get_ge method that takes as arguments the group and element number of the Data Element.
      </p><p>
      For example, to retrieve the value of the Patient ID Data Element using it's group and element pair (0x0010,0x0020):
    </p>
      <pre><code class="lang-java">String patientID = (String) dcm.get_ge (0x0010,0x0020);</code></pre>
      <p>
        Otherwise the value can also be retrieved using the DDict constant DDict.dPatientID corresponding to the Data Element:
      </p>
      <pre><code class="lang-java">String patientID = (String) dcm.get (DDict.dPatientID);</code></pre>
      <p>
        In this example the value is returned as String, because the patient ID Data Element has Value Representation LO which is mapped to the String class.
      </p>
      <h5>B] The Data Element contains multiple values</h5>
      <p>
        A Data Element can have a multiplicity greater than 1, which means that there can be multiple values stored within the Data Element.
        To retrieve a particular value out of a Data Element containing multiple values use the get or get_ge method with an additional index argument.
      </p><p>
      Use the getSize method to retrieve the actual number of values stored within the Data Element.
    </p><p>
      For example, suppose a DicomObject dcm contains an ImageType Data Element with multiplicity 2 and values 'DERIVED\SECONDARY'.
      (The backslash separates the different values in the Data Element for this particular Value Representation). You retrieve the values as follows:
    </p>
        <pre><code class="lang-java">String str1 = (String)dcm.get(DDict.dImageType,0); //will return 'DERIVED'
          String str2 = (String)dcm.get(DDict.dImageType,1); //will return 'SECONDARY'</code></pre>
      Alternatively using the (group,element) pair:

        <pre><code class="lang-java">String str1 = (String)dcm.get(0x0008,0x0008,0); //will return 'DERIVED'
          String str2 = (String)dcm.get(0x0008,0x0008,1); //will return 'SECONDARY'</code></pre>

      <h4>Retrieving values of a Data Element contained in a Sequence Item</h4>
      <p>
        Values of a Data Element contained within a Sequence are retrieved in much the same way as values with a multiplicity greater than one.
        When a Data Element in a DicomObject represents a Sequence (DICOM Value Representation SQ),
        then the individual items of the Sequence  are internally stored as objects of type DicomObject themselves and can be retrieved with the same get methods of DicomObject.
        The returned object will be itself an instance of the DicomObject class.
      </p><p>
      For example, suppose a DicomObject dcm contains a Scheduled Procedure Step Sequence with 3 Sequence Items
      and suppose a value must be retrieved of the Scheduled AE Title Data Element in the second Sequence Item.
    </p>
        <pre><code class="lang-java">int numberofitems = dcm.getSize( DDict.dScheduledProcededureStepSequence );
          DicomObject item = (DicomObject)dcm.get( DDict.dScheduledProcededureStepSequence ,1);
          String aeTitle = (String)item.get( DDict.dScheduledStationAETitle );</code></pre>

      <p>
        There is no limit on the levels of nesting of sequences. A DicomObject that is retrieved as an item of a Sequence can itself contain Sequences.
      </p>
      <p>
        A utility class <code>com.archimed.dicom.tools.Sequences</code> exist which contains various methods for direct retrieval of values of Data Elements contained within items of a Sequence.
        This class supports retrieving values in Data Elements contained in Sequence Items up to two levels deep.
      </p>
      <p>
        <strong>Note:</strong> Group lengths are not stored within a DicomObject so there is no way of retrieving group lengths
      </p>

      <h1 id="updatingvalues">Adding and Updating values of a Data Element</h1>
      <p>
        The DicomObject class contains set and and append methods to add and update values of Data Elements.
        A Data Element can be identified by specifying a DDict constant or by specifying the group-element pair of the Data Element.
      </p>
      <h4>Adding or Updating a Data Element with a Single Value</h4>
      <p>
        For example use the DDict constant DDict.dPatientID to add a new Patient ID Data Element to a DicomObject or update an existing Patient ID Data Element:
      </p>
        <pre><code class="lang-java">DicomObject dcm = new DicomObject();
          dcm.set(DDict.dPatientID,"PTI12324");</code></pre>
      <p>
        or alternatively use the group-element pair of the Patient ID Data Element:
      </p>
        <pre><code class="lang-java">DicomObject dcm = new DicomObject();
          dcm.set_ge(0x0010,0x0020,"PTI12324");</code></pre>

      <p>
        If this method is used on a Data Element which contains multiple values, the first value is updated.
      </p>

      <h4>Making a Data Element empty</h4>
      <p>
        To add an empty Data Element or to update a Data Element so that is becomes empty, use null as an argument:
      </p>

        <pre><code class="lang-java">DicomObject dcm = new DicomObject();
          dcm.set(DDict.dPatientID,null);</code></pre>

      <h4>Adding or Updating a Data Element with a Multiple Values</h4>
      <p>
        To add a value to a Data Element with multiple values or to update a particular value in a Data Element with multiple values,
        use the set or set_ge methods that take an extra index argument:
      </p>
        <pre><code class="lang-java">dcm.set(DDict.dImageType,0,"DERIVED");
          dcm.set(DDict.dImageType,1,"SECONDARY");</code></pre>

      <p>
        One can also use an append method to add multiple values to a Data Element:
      </p>
        <pre><code class="lang-java">dcm.append(DDict.dImageType,"DERIVED");
          dcm.append(DDict.dImageType,"SECONDARY");</code></pre>
      <p>
        In the example above, the first call to append will create a new Data Element in the DicomObject with a single value 'DERIVED' and the second call
        to append will add an extra value 'SECONDARY' to the Data Element.
      </p>
      <p>
        The set and set_ge methods will throw a <code>DicomException</code> if the specified index is greater than the current number of values contained in the Data Element.
        For example the following code will throw a DicomException at the second call to set:
      </p>
        <pre><code class="lang-java">dcm.set(DDict.dImageType,0,"DERIVED");
          dcm.set(DDict.dImageType,3,"SECONDARY");</code></pre>

      <h4>Making a specific value of multi-valued Data Element empty</h4>
      <p>
        To set a specific value in a multi-valued Data Element to empty, use the set method with a null argument and with the particular index:
      </p>
        <pre><code class="lang-java">dcm.set(DDict.dOtherPatientID,0,"AKA22334");
          dcm.set(DDict.dOtherPatientID,1,null);
          dcm.set(DDict.dOtherPatientID,2,"AZE-2322-2099");</code></pre>
      <p>
        In the example above, the second value of the Other Patient ID Data Element will be set to empty.
      </p>
      <h4>Removing a Data Element</h4>
        <pre><code class="lang-java">//Use the deleteItem method to remove an entire Data Element from a DicomObject:
          Vector v = dcm.deleteItem(DDict.dPatientID);</code></pre>
      <p>
        A Vector with all the values of the removed Data Element is returned.
      </p>
      <h4>Removing a particular value from a Data Element</h4>
      <p>
        Use the deleteItem method with an extra index argument to remove a particular value from a Data Element:
      </p>
      <pre><code class="lang-java">Object o = dcm.deleteItem(DDict.dOtherPatientID,2);</code></pre>
      <p>
        The value that is removed from the Data Element is returned. The values with a higher index are shifted downwards.
      </p>
      <h4>Sequences</h4>
      <p>
        Sequence Items are represented as instances of DicomObject. To manipulate values of Data Elements contained within a Sequence Item,
        use the set,append and deleteItem methods on the instance of the DicomObject representing the Sequence Item.
        The add,modify and remove entire Sequence Items in a Sequence, use the set,append and deleteItem methods on the DicomObject that contains the Sequence.
      </p><p>
      For example, to add a Sequence Data Element to a DicomObject:
    </p>
        <pre><code class="lang-java">//create a first sequence item
          DicomObject sequenceItem1 = new DicomObject();
          sequenceItem1.set(DDict.dRetrieveAETitle,"SERVER12");
          sequenceItem1.set(DDict.dSeriesInstanceUID,"1.295.34533.33335.23");

          //create a second sequence item
          DicomObject sequenceItem2 = new DicomObject();
          sequenceItem2.set(DDict.dRetrieveAETitle,"SERVER07");
          sequenceItem2.set(DDict.dSeriesInstanceUID,"1.295.34533.35454.17");

          //add the items to a Sequence Data Element of a DicomObject
          DicomObject dcm = new DicomObject();
          dcm.set(DDict.dReferencedSeriesSequence,1,sequenceItem1);
          dcm.set(DDict.dReferencedSeriesSequence,2,sequenceItem2);</code></pre>


      <h1 id="listing">Listing the contents of a DICOM file</h1>
      <p>
        On a number of occasions it can be useful to generate a list of the Data Elements of a DICOM file as formatted text.
        This can be done directly with the <code>DicomObject.dumpVRs</code> methods or with the class <code>com.archimed.dicom.DumpUtils</code>
        that gives some more control over the formatting.
        Regardless of which method is used, all data elements are always listed in a tabular format with columns
      </p>
      <ul>
        <li>tag number of the data element
        <li>data element description
        <li>VR type
        <li>length
        <li>multiplicity
        <li>value
      </ul>
      <p>
        To reflect the nested sequence structure of DICOM file, Data elements contained in sequences are indented.
        The size of the indentation is dependent on the sequence depth. Values of type OW or OB (eg: pixeldata) are cutoff at a fixed number of bytes.
      </p>

      <h4>Using the dump methods in DicomObject</h4>
      <p>
        The <code>DicomObject</code> class contains two methods that write the contents of the object to an outputstream as formatted text:
      </p>
      <ul>
        <li><code>DicomObject.dumpVRs (java.io.OutputStream os)</code>
        <li><code>DicomObject.dumpVRs (java.io.OutputStream os,boolean metainfo)</code>
      </ul>
      <p>
        The first method will list the data elements of the File Meta Information.
        The second method will list the data elements of the File Meta Information if the metainfo argument is set to true.
      </p>
      <h4>Using the com.archimed.dicom.DumpUtils class</h4>
      <p>
        The <code>com.archimed.dicom.DumpUtils</code> class allows one to specify:
      </p>
      <ul>
        <li>the character width of the data element description column
        <li>the character width of the value column
        <li>the character width of the indention for data elements contained in sequences
        <li>whether or not to list File Meta Information Data Elements.
      </ul>
      <h4>Examples</h4>

        <pre><code class="lang-java">DicomObject dcm = new DicomObject;
          dcm.read(new FileInputStream("foo.dcm"));
          dcm.dumpVRs(System.out, true);</code></pre>

        <pre><code class="lang-java">DicomObject dcm = new DicomObject;
          dcm.read(new FileInputStream("foo.dcm"));
          DumpUtils du = new DumpUtils(40,70,8,true);
          du.dump(dcm,os);</code></pre>

      <h1 id="charsets">Working with extended or replacements charsets</h1>
      <p> The DICOM standard supports the usage of non-ASCII character sets for various value representations (see Dicom Standard Part V) . If a DICOM file or DICOM dataset has tag values encoded in other character sets than the default , the used character sets must be specified in the SpecificCharacterSet tag (0x0008,0x0005). In general this tag can be multi-valued as multiple character sets can be used in a single DICOM file or DICOM dataset with the code extensions technique.
      </p>
      <p>When retrieving non-default charset encoded values out of DicomObjects, JDT will represent them as String objects hereby decoding the values in the dataset or DICOM file into a Unicode String. JDT relies here on the fact that Java Strings are Unicode and every used DICOM character set can be properly represented as a java String object. JDT will use the character sets specified in the SpecificCharacterSet tag when converting data element values into Java Strings.
      </p>
      <h4>Retrieving values encoded with a non-default charset</h4>
      <p>
        When retrieving values as Strings for value representations that support non-default charsets,
        JDT will try to convert the values to proper Unicode Strings. For example, suppose we have a DicomObject which contains a value
        for the StudyDescription tag encoded in a non-default charset. Then doing
      </p>

      <pre><code class="lang-java">String studyDescription = dcm.getString(DDict.dStudyDescription,0);</code></pre>

      <p>will retrieve the first value of the StudyDescription tag into a String. JDT will internally take into account the value of the SpecificCharset tag to do a correct conversion into a Unicode String.</p>

      <h4>Setting values encoded in a non-default charset and using multiple character sets</h4>
      <p>
        When using the DicomObject.setString methods on data elements with a value representation that supports non-default charsets,
        JDT will try to encode the String according to the character sets specified in the SpecificCharacterSet data element of the DicomObject:
      </p>
      <ul>
        <li>If the SpecificCharacterSet data element is empty or missing, JDT will try to encode the string using the DICOM default character set (US-ASCII)
        <li>If the SpecificCharacterSet data element contains a single value, JDT will try to encode the entire string with the specified character set stored in the single value
        <li>If the SpecificCharacterSet data element is multi-valued, JDT will try to encode every character of the specified string with the first character set in the SpecificCharacterSet data element.If a character cannot be encoded using the first character set of the SpecificCharacterSet data element, JDT will try with the other character sets in following the order of the values of the SpecificCharacterSet element, until one is found that can encode the character or an Exception is thrown if no character set is able to encode the character.
      </ul>
      <p><strong>Note: </strong>When encoding with multiple character sets (.3), JDT will use proper character set escape sequences according to the code extension technique described in the DICOM standardand will take into account DICOM control characters that may be present in the strings to be encoded and that trigger switching of the active character set to the first character set of a multi-valued SpecificCharacterSet data element.</p>

      <p>For example suppose we have a java String object studyDescription that contains characters in Greek. This value can be encoded properly in the Greek characterset (ISO_IR_126) if before the studyDescription value is set, the SpecificCharset tag is initialized:</p>

         <pre><code class="lang-java">DicomObject dcm = new DicomObject();
           dcm.setString(DDict.dSpecificCharacterSet,DicomCharset.ISO_IR_126.getDefinedTerm(),0);
           dcm.setString(DDict.dStudyDescription,0,studyDescription, DicomCharset.ISO_IR_126);</code></pre>

      <p><strong>Note:</strong> In order for this to work with DicomObjects that are sequence items, the items must first be set into their parent DicomObject. For example:</p>

         <pre><code class="lang-java">DicomObject parent = new DicomObject();
           DicomObject item = new DicomObject();

           //always set the charset tag first
           parent.setString(DDict.dSpecificCharacterSet,DicomCharset.ISO_IR_126.getDefinedTerm(),0);

           //link the item with its parent first before encoding Strings in non-default charsets
           parent.setSequenceItem(DDict.dSomeSequence,item,0);

           //now the string with non-default characters can be set properly
           item.setString(DDict.dSomeTag,0,someStringWithGreekChars, DicomCharset.ISO_IR_126);</code></pre>

      <p>This will allow the setString method call to lookup the specified character set in the parent DicomObject.</p>

      <h4>Using Unicode UTF-8 character sets (ISO_IR 192)</h4>

      <p>DICOM supports the use of Unicode encoded in UTF-8, which makes it possible to support different languages all with the same encoding. The use of of Unicode UTF-8 is recommended when it is a requirement to support multiple character sets covering different languages.</p>

      <p>When creating new DICOM files or datasets that will contain tags encoded in Unicode UTF-8, one must set the SpecificCharacterSet tag to DicomCharset.ISO_IR_192.</p>

        <pre><code class="lang-java">DicomObject dcm = new DicomObject();
          dcm.setString(DDict.dSpecificCharacterSet, DicomCharset.ISO_IR_192.getDefinedTerm(), 0);</code></pre>

      <h4>Retrieving PN values encoded with non-default charsets</h4>
      <p>One of the typical uses of non-default charsets is in the encoding of PN data elements.To retrieve the value of a PN data element you can do</p>

      <pre><code class="lang-java">Person patientName = dcm.getPersonName(DDict.dPatientName, 0);</code></pre>
      <p>The different attributes of the Person object, each representing a person name component (eg lastname,firstname,...) of a particular component group(single byte,phonetic,ideographic) will be properly filled in if available in the tag value. JDT will convert the patient name into a Unicode String representation and fill all components for the 3 component groups. Alternatively one can also do</p>
      <pre><code class="lang-java">String patientName = dcm.getString(DDict.dPatientName, 0);</code></pre>
      <p>This will result in a person name string according to the DICOM format for PN valued tags with group delimiters(^)and component delimiters(=).</p>

      <p>Lastly every data element value can always be retrieved directly as byte[] array.</p>

      <pre><code class="lang-java">byte[] patientName = dcm.getBytes(DDict.dPatientName, 0);</code></pre>
      <p><strong>Note:</strong> In order for java Strings containing non-ASCII characters to be displayed properly in a GUI or on the command-line, the chosen fonts must support the characters represented in the java Strings</p>

      <h4>Using ideographic and phonetic representations in PN tags (code extension techniques)</h4>
      <p>JDT supports the use of code extension techniques in PN data elements. This allows you to encode the ideographic and phonetic representations of a person name in other character sets. This is typically useful in Japanese and Korean. The DicomObject class a version of setPersonName and addPersonName with which you can specify the character sets that should be used for the encoding of the three different component groups (single-byte,ideographic and phonetic) of a PN data element.</p>

      <p><strong>Note:</strong> In order to produce correct DICOM files and datasets, the used character sets must also be specified in the SpecificCharset (0008,0005) tag. In particular the used charset for the single-byte component group of a PN data element must correspond with the first value of a multi-valued SpecificCharset tag. An empty first value of the SpecificCharset tag means that the default charset (ISO_IR_6) must be used for the single-byte component group.</p>

      <h4>Example: Using ideographic and phonetic representations in Japanese (Yamada Tarou)</h4>
      <p>Appendix H of Part 5 of the DICOM standard contains examples of PN data elements with ideographic and phonetic representations in Japanese character sets. Here we show how to reproduce one of these examples.</p>

      <p>If you start from an new DicomObject, first create and set the SpecificCharset tag:</p>

        <pre><code class="lang-java">//create a new DicomObject and initialize SpecificCharset tag
          //with charset that you want to use in the DicomObject
          DicomObject dcm = new DicomObject();
          dcm.setString(DDict.dSpecificCharacterSet,DicomCharset.ISO_2022_IR_13.getDefinedTerm(),0);
          dcm.setString(DDict.dSpecificCharacterSet,DicomCharset.ISO_2022_IR_87.getDefinedTerm(),1);</code></pre>

      <p>Create a new Person object and fill it in properly. For the sake of the example, we initialize the values of the ideographic and phonetic representations through Unicode escape sequences. In a normal application the String properties for the ideographic and phonetic representations will most often be initialized from keyboard input.</p>

        <pre><code class="lang-java">Person person = new Person();
          person.familyName            = "Yamada";
          person.givenName             = "Tarou";
          person.familyNameIdeographic = "\u5c71\u7530";
          person.givenNameIdeographic  = "\u592a\u90ce";
          person.familyNamePhonetic    = "\u3084\u307e\u3060";
          person.givenNamePhonetic     = "\u305f\u308d\u3046";</code></pre>

      <p>Use the setPersonName method of DicomObject that takes the used charsets as extra arguments. There is one charset argument per component group of a PN tag.</p>

        <pre><code class="lang-java">//create an empty patient name tag and fill it with the values of the Yamada Tarou file
          dcm.setPersonName(DDict.dPatientName, person, 0, DicomCharset.ISO_2022_IR_6,
          DicomCharset.ISO_2022_IR_87,
          DicomCharset.ISO_2022_IR_87);</code></pre>

    </div>
  </div>
</div>

@@include('../partials/_footer.html')

@@include('../partials/_script.html')

</body>
</html>

